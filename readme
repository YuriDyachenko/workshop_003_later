- - - - - - - - - - - - - - - - - - - - задание 1 - - - - - - - - - - - - - - - - - - - -

Сегодня поработаем с массивами. Давайте напишем функцию, которая на вход получает массив слов. Например:
["apple banana", "orange", "banana", "kiwi strawberry blueberry"]
Видно, что в этом массиве в некоторых слотах затесалось сразу несколько слов. На выходе функция
должна вернуть такой массив, где одно слово будет в каждом элементе:
["apple", "banana", "orange", "banana", "kiwi", "strawberry", "blueberry"]
Словом считается любой набор символов, обособленный пробелами или началом/концом строки.

- - - - - - - - - - - - - - - - - - - - задание 2 - - - - - - - - - - - - - - - - - - - -

Сегодня задача №2 не связана с первой задачей. Сегодня мы напишем функцию, которая снова на вход
получает текст и ищет в нем слова паразиты. Словами-паразитами называются слова, которые встречаются
в тексте >= N раз, где N - целочисленный параметр, который передается вторым параметром в функцию.
Несколько правил:
- Словом считается любой набор символов, обособленный слева и справа пробелами ИЛИ началом/концом строки.
- Слова с разным регистром считаются одним и тем же словом. То есть предлог "под", который мы можем встретить
 в середине предложения и "Под" - в начале предложения - одно и то же слово.
- Знаки препинания не учитываются. То есть "привет." и "привет" - это одно и то же слово.
Гарантируется, что текст будет только на русском или английском языках.
Результат вернуть JSON'ом, где ключи - слова-паразиты, а значение - количество раз, которое оно встречается.
Пример:
Дано:
text: "Ну что ж я, я найти решения правильного не смогу ж? Смогу ж конечно, я ж старательный все ж таки."
max_amount: 3
Ответ:
{
 "я":3,
 "ж":5
}
